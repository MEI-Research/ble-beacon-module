/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * TiDev Titanium Mobile
 * Copyright TiDev, Inc. 04/07/2022-Present
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */

package com.pilrhealth.beacon

import android.os.Build
import androidx.annotation.RequiresApi
import com.pilrhealth.AppMessageQueue
import org.appcelerator.kroll.KrollModule
import org.appcelerator.kroll.KrollDict
import org.appcelerator.kroll.annotations.Kroll
import org.appcelerator.kroll.common.Log
import org.appcelerator.kroll.common.TiConfig
import org.appcelerator.titanium.TiApplication
import org.json.JSONObject

@RequiresApi(Build.VERSION_CODES.O)
@Kroll.module(name = "BleBeacon", id = "com.pilrhealth.beacon")
class BleBeaconModule: KrollModule() {

	// NOTE: You can develop Titanium Android modules in Android Studio. Follow these three steps:
	//   1. Build the empty module
	//   2. Drag the "build" folder into Android Studio
	//   3. Start developing! All dependencies and code completions are supported!

	companion object {
		// Standard Debugging variables
		private const val LCAT = "BleBeaconModule"
		private val DBG = TiConfig.LOGD

		// You can define constants with @Kroll.constant, for example:
		// @Kroll.constant private val EXTERNAL_NAME = "EXTERNAL_NAME"

		@Kroll.onAppCreate
		fun onAppCreate(app: TiApplication?) {
			// THis log message doesn't work for some reason, but this method gets called.
			// The foreground service will cause the TiApplication to be created and this is called.
			Log.d(LCAT, "inside onAppCreate")
			// put module init code that needs to run when the application is created
			//BeaconDetector.start("onAppCreate")
		}
	}

	init {
		AppMessageQueue.appLog("BleBeaconModule created")
	}

	@Kroll.method
	fun startBeaconDetection() {
		Log.e(LCAT, "starting detection")
		AppMessageQueue.owner = this
		return BeaconDetector.start("startBeaconDetection")
	}

	@Kroll.method
	fun fetchEvents() = AppMessageQueue.fetchMessages()

	@Kroll.method
	fun fetchNextMessage(): KrollDict? =
		AppMessageQueue.fetchNextMessage()?.let { KrollDict(it) }


	@Kroll.method
	fun setFriendList(str: String) {
		Encounter.friendList = str
		Log.i(LCAT, "friendList = '${Encounter.friendList}'")
	}

	/** This should be called when EMA logs out */
	@Kroll.method()
	fun clearAllEncounters() {
		setFriendList("")
	}

	@set:Kroll.setProperty
	var notificationTitle: String by EncounterNotifier::notificationTitle

	@set:Kroll.setProperty
	var notificationText: String by EncounterNotifier::notificationText

	@set:Kroll.setProperty
	var transientTimeoutSecs: Long
		get() {
			return Encounter.transientEncounterTimeout / 1000
		}
		set(value) {
			Encounter.transientEncounterTimeout = value * 1000
		}

	@set:Kroll.setProperty
	var actualTimeoutSecs: Long
		get() {
			return Encounter.actualEncounterTimeout / 1000
		}
		set(value) {
			Encounter.actualEncounterTimeout = value * 1000
		}

	// Scan stats & parameters

	@Kroll.method
	fun scanStats(): KrollDict {
		return KrollDict(BeaconDetector.scanTimes.stats())
	}

	@set:Kroll.setProperty
	var betweenScanPeriod by BeaconDetector::betweenScanPeriod

	@set:Kroll.setProperty
	var scanPeriod by BeaconDetector::scanPeriod
}
